0x00 ##sol
0x01 ##eol
0x02 ##internal
0x03 :
0x04 load
0x05 save
0x06 con
0x07 run first.run.linenum
0x08 run
0x09 del
0x0a , next.del.aexpr
0x0b new
0x0c clr
0x0d auto
0x0e , next.auto.aexpr
0x0f man
0x10 himem:
0x11 lomem:
0x12 + binary.aexpr
0x13 - binary.aexpr
0x14 *
0x15 /
0x16 = rel.aexpr
0x17 # rel.aexpr
0x18 >=
0x19 >
0x1a <=
0x1b <>
0x1c <
0x1d and
0x1e or
0x1f mod
0x20 ^
0x21
0x22 ( first.dim.svar.aexpr
0x23 , next.svar.sub.aexpr
0x24 then next.linenum
0x25 then next.assign.aexpr
0x26 , next.input.sexpr
0x27 , next.input.aexpr
0x28 " first.sliteral
0x29 " last.sliteral
0x2a ( next.svar.sub.aexpr
0x2b
0x2c
0x2d ( array.avar
0x2e peek
0x2f rnd
0x30 sgn
0x31 abs
0x32 pdl
0x33 
0x34 ( dim.avar
0x35 + unary.aexpr
0x36 - unary.aexpr
0x37 not rel.aexpr
0x38 ( expr.parenthesized
0x39 = rel.sexpr
0x3a # rel.sexpr
0x3b len(
0x3c asc(
0x3d scrn(
0x3e , next.scrn.aexpr
0x3f ( functions.peek.rnd.sgn.abs.pdl
0x40 $
0x41
0x42 ( assign.substr
0x43 , next.dim.svar
0x44 , next.dim.avar
0x45 ; next.print.sexpr
0x46 ; next.print.aexpr
0x47 ; last.print
0x48 , next.print.sexpr
0x49 , next.print.aexpr
0x4a , last.print
0x4b text
0x4c gr
0x4d call
0x4e dim dim.svar
0x4f dim dim.avar
0x50 tab
0x51 end
0x52 input svar
0x53 input sliteral
0x54 input avar
0x55 for
0x56 = assign.for
0x57 to
0x58 step
0x59 next
0x5a , next.next.avar
0x5b return
0x5c gosub
0x5d rem
0x5e let
0x5f goto
0x60 if
0x61 print sexpr
0x62 print aexpr
0x63 print lf
0x64 poke
0x65 , next.poke.aexpr
0x66 color=
0x67 plot
0x68 , next.plot.aexpr
0x69 hlin
0x6a , next.hlin.aexpr
0x6b at next.hlin.aexpr
0x6c vlin
0x6d , next.vlin.aexpr
0x6e at next.vlin.aexpr
0x6f vtab
0x70 = assign.svar
0x71 = assign.avar
0x72 )
0x73
0x74 list linenum
0x75 , next.list.aexpr
0x76 list
0x77 pop
0x78 nodsp svar
0x79 nodsp avar
0x7a notrace
0x7b dsp svar
0x7c dsp avar
0x7d trace
0x7e pr#
0x7f in#
